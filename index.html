<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>kVT AI LIVE SIGNAL Dashboard (Firebase Edition)</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
  rel="stylesheet"
/>
<style>
  :root {
    --bg: #0f172a;
    --panel: #1e293b;
    --accent: #4ade80;
    --danger: #ef4444;
    --warn: #fbbf24;
    --text: #e2e8f0;
    --text-muted: #94a3b8;
    --blue: #60a5fa;
    --error: #737373;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: Poppins, Segoe UI, sans-serif;
    background: var(--bg);
    color: var(--text);
  }
  header {
    background: #020617;
    padding: 1rem 2rem;
    text-align: center;
    user-select: none;
  }
  header h1 {
    color: var(--accent);
    font-size: 1.8rem;
    letter-spacing: 1px;
    margin: 0;
  }
  main {
    padding: 1rem 2rem 2rem;
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
  #tvChart {
    width: 100%;
    height: 500px;
    border-radius: 12px;
    border: 1px solid #334155;
  }
  #controlsPanel {
    background: var(--panel);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 1.5rem;
  }
  #symbolSelect, #balanceInput {
    background: #334155;
    color: var(--text);
    border: none;
    border-radius: 6px;
    padding: 0.5rem 1rem;
    font-size: 1rem;
  }
  #balanceInput { width: 150px; }
  #positionAdvice {
    color: var(--accent);
    font-size: 0.9rem;
    font-weight: 600;
    user-select: none;
    flex-grow: 1; text-align: right;
  }
  #signalsContainer {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 1.5rem;
  }
  .signals-section {
    background: var(--panel);
    border-radius: 12px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    min-height: 300px;
  }
  .signals-section h2 {
    color: var(--blue);
    margin: 0 0 0.5rem 0;
    font-size: 1.2rem;
    border-bottom: 1px solid #334155;
    padding-bottom: 0.75rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #analysisStatus {
    font-size: 0.8rem;
    font-weight: 400;
    color: var(--warn);
    animation: blink 2s infinite;
  }
  @keyframes blink { 50% { opacity: 0.5; } }
  .signals-box {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    overflow-y: auto; flex-grow: 1;
  }
  .signal-card {
    background: var(--bg);
    border: 1px solid #334155;
    border-left: 5px solid var(--blue);
    border-radius: 8px;
    padding: 1rem;
    transition: 0.3s;
    user-select: none;
    font-size: 0.9rem;
    cursor: pointer;
  }
  .signal-card:hover { border-color: var(--blue); }
  .signal-card.status-live { border-left-color: var(--warn); }
  .signal-card.status-win { border-left-color: var(--accent); }
  .signal-card.status-loss { border-left-color: var(--danger); }
  .signal-card.status-error { border-left-color: var(--error); }

  .signal-card p { margin: 0.3rem 0; }
  .signal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
  .signal-header strong { font-size: 1.1rem; }
  .signal-header .type-buy { color: var(--accent); }
  .signal-header .type-sell { color: var(--danger); }
  .price-up { color: var(--accent); }
  .price-down { color: var(--danger); }
  .signal-pnl { font-weight: 600; font-size: 1.1rem; }
  .signal-footer { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.75rem; }

  #marketTableContainer { background: var(--panel); border-radius: 12px; padding: 1rem; }
  #marketTableContainer h2 { color: var(--blue); margin: 0 0 0.75rem 0; font-size: 1.1rem; }
  .live-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
  .live-table th, .live-table td { padding: 0.5rem 0.75rem; text-align: center; border-bottom: 1px solid #334155; }
</style>
</head>
<body>
<header><h1>kVT AI LIVE SIGNAL</h1></header>
<main>
  <div id="tvChart"></div>

  <div id="controlsPanel">
    <select id="symbolSelect"></select>
    <label for="balanceInput" style="color: var(--text); font-weight: 600; user-select:none;">
      Your Balance (USD):
    </label>
    <input type="number" id="balanceInput" value="1000" min="10" step="1" />
    <div id="positionAdvice">Click a signal for position size advice</div>
  </div>

  <div id="signalsContainer">
    <section class="signals-section">
      <h2>Live Signals <span id="analysisStatus"></span></h2>
      <div id="liveSignalsBox" class="signals-box"><p>No live signals.</p></div>
    </section>

    <section class="signals-section">
      <h2>New Signals (Awaiting Entry)</h2>
      <div id="newSignalsBox" class="signals-box"><p>No new signals approved.</p></div>
    </section>

    <section class="signals-section">
      <h2>Trade History</h2>
      <div id="historyBox" class="signals-box"><p>No trade history.</p></div>
    </section>
  </div>

  <div id="marketTableContainer">
    <h2>All Markets (1s Refresh)</h2>
    <table class="live-table" id="marketTable">
      <thead><tr><th>Pair</th><th>Price</th><th>24h %</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</main>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<script src="https://s3.tradingview.com/tv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios@1.6.8/dist/axios.min.js"></script>
<script>
// =================================================================
// 1. CONFIGURATION & INITIALIZATION
// =================================================================
const symbols = [
    { code: "BINANCE:BTCUSDT", label: "BTC/USDT" }, { code: "BINANCE:ETHUSDT", label: "ETH/USDT" },
    { code: "BINANCE:BNBUSDT", label: "BNB/USDT" }, { code: "BINANCE:SOLUSDT", label: "SOL/USDT" },
    { code: "BINANCE:XRPUSDT", label: "XRP/USDT" }, { code: "OANDA:XAUUSD", label: "GOLD" },
    { code: "TVC:USOIL", label: "US OIL" }, { code: "NASDAQ:TSLA", label: "TSLA" } // A smaller list for more frequent signals
];
const TRADE_RISK_PERCENT = 2.0; // Risk 2% of balance per trade

// --- DOM Elements ---
const symbolSelect = document.getElementById("symbolSelect");
const balanceInput = document.getElementById("balanceInput");
const adviceBox = document.getElementById("positionAdvice");
const tableBody = document.querySelector("#marketTable tbody");
const liveSignalsBox = document.getElementById("liveSignalsBox");
const newSignalsBox = document.getElementById("newSignalsBox");
const historyBox = document.getElementById("historyBox");
const analysisStatus = document.getElementById("analysisStatus");

// --- State Variables ---
let tvWidget;
let allSignals = []; // Local cache of signals, populated from Firebase
let lastPrices = {}; // Stores latest price for each symbol

// --- Firebase Configuration (from your google-services.json) ---
// IMPORTANT: For this to work, you MUST enable public read/write access
// in your Firebase Realtime Database rules. This is NOT secure for production.
const firebaseConfig = {
    apiKey: "AIzaSyBhATVeER6lVomkHqfvbtcM8j-xhLR8ZyY",
    authDomain: "ff-cash-587aa.firebaseapp.com",
    databaseURL: "https://ff-cash-587aa-default-rtdb.firebaseio.com",
    projectId: "ff-cash-587aa",
    storageBucket: "ff-cash-587aa.appspot.com",
};

// --- Initialize Firebase ---
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
const signalsRef = database.ref('signals');


// =================================================================
// 2. CORE APPLICATION LOGIC
// =================================================================

function initializeApp() {
    populateSymbolDropdown();
    loadChart(symbolSelect.value);

    // Main listener: gets data on load and listens for any changes in Firebase
    signalsRef.on('value', (snapshot) => {
        const data = snapshot.val();
        allSignals = data ? Object.values(data) : [];
        console.log("Data loaded from Firebase. Total signals:", allSignals.length);
        // We have new data, so immediately run the processing and rendering
        processSignals();
        renderAllSignals();
    });

    // Start background processes
    setInterval(refreshMarketData, 1500); // Get prices
    setInterval(signalScanner, 20000); // Look for potential trades
    setInterval(secondaryAnalyzer, 7000); // Approve potential trades
}

// =================================================================
// 3. SIGNAL PROCESSING PIPELINE
// =================================================================

// STEP A: AI Scanner finds "potential" trades
function signalScanner() {
    analysisStatus.style.display = 'inline';
    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
    const priceData = lastPrices[randomSymbol.code];
    
    // Condition to generate a signal: price data must exist and no active/new signal for this pair
    const hasExistingSignal = allSignals.some(s => s.symbolCode === randomSymbol.code && (s.status === 'new' || s.status === 'live' || s.status === 'potential'));

    if (priceData && !hasExistingSignal) {
        const basePrice = priceData.price;
        const dir = Math.random() > 0.5 ? "BUY" : "SELL";
        const volatility = 0.02; // 2%
        
        const entry = basePrice * (dir === 'BUY' ? 0.998 : 1.002);
        const sl = entry * (dir === 'BUY' ? (1 - volatility) : (1 + volatility));
        const tp1 = entry * (dir === 'BUY' ? (1 + volatility * 0.7) : (1 - volatility * 0.7));
        const tp2 = entry * (dir === 'BUY' ? (1 + volatility * 1.5) : (1 - volatility * 1.5));
        
        const signalId = Date.now(); // Unique ID
        const newSignal = {
            id: signalId,
            pair: randomSymbol.label,
            symbolCode: randomSymbol.code,
            status: 'potential', // <<< STARTS AS POTENTIAL
            type: dir,
            entry, sl, tp: [tp1, tp2],
            winChance: Math.floor(50 + Math.random() * 45), // 50% to 95%
            createdAt: new Date().toISOString(),
        };

        // Save to Firebase
        database.ref('signals/' + signalId).set(newSignal);
    }
    setTimeout(() => { analysisStatus.style.display = 'none'; }, 2000);
}

// STEP B: A secondary process "approves" high-probability signals
function secondaryAnalyzer() {
    const potentialSignals = allSignals.filter(s => s.status === 'potential');
    if (potentialSignals.length === 0) return;

    potentialSignals.forEach(signal => {
        if (signal.winChance > 75) { // <<< APPROVAL THRESHOLD
            const updates = { status: 'new' };
            // Update only the status field in Firebase
            database.ref('signals/' + signal.id).update(updates);
        }
    });
}

// STEP C: Main processor checks for state changes (New -> Live -> Closed)
function processSignals() {
    const balance = parseFloat(balanceInput.value) || 0;

    allSignals.forEach(signal => {
        const currentPriceData = lastPrices[signal.symbolCode];
        if (!currentPriceData && (signal.status === 'live' || signal.status === 'new')) {
             database.ref('signals/' + signal.id).update({ status: 'error', result: 'Price data lost' });
             return;
        }
        if (!currentPriceData) return;

        const currentPrice = currentPriceData.price;
        const updates = {}; // Object to hold any changes to be sent to Firebase

        // Check NEW signals to see if they should become LIVE
        if (signal.status === 'new') {
            const hasHitEntry = (signal.type === 'BUY' && currentPrice <= signal.entry) ||
                                (signal.type === 'SELL' && currentPrice >= signal.entry);
            if (hasHitEntry) {
                updates.status = 'live';
                updates.entryTime = new Date().toISOString();
                
                // Calculate position size (quantity) on entry
                const riskUsd = (balance * TRADE_RISK_PERCENT) / 100;
                const diff = Math.abs(signal.entry - signal.sl);
                updates.quantity = (riskUsd / diff);
            }
        }
        
        // Check LIVE signals for TP/SL hits or P/L updates
        if (signal.status === 'live') {
            const pnl_usd = (currentPrice - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
            updates.pnl_usd = pnl_usd;
            
            const hasHitSL = (signal.type === 'BUY' && currentPrice <= signal.sl) ||
                             (signal.type === 'SELL' && currentPrice >= signal.sl);
            if (hasHitSL) {
                updates.status = 'closed';
                updates.result = 'Loss';
                updates.closePrice = signal.sl;
                updates.pnl_usd = (signal.sl - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
            } else {
                for (let i = signal.tp.length - 1; i >= 0; i--) {
                    const tpPrice = signal.tp[i];
                    const hasHitTP = (signal.type === 'BUY' && currentPrice >= tpPrice) ||
                                     (signal.type === 'SELL' && currentPrice <= tpPrice);
                    if (hasHitTP) {
                        updates.status = 'closed';
                        updates.result = `Win (TP${i+1})`;
                        updates.closePrice = tpPrice;
                        updates.pnl_usd = (tpPrice - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
                        break;
                    }
                }
            }
        }
        
        // If there are any updates, send them to Firebase
        if (Object.keys(updates).length > 0) {
            database.ref('signals/' + signal.id).update(updates);
        }
    });
}


// =================================================================
// 4. UI RENDERING
// =================================================================

function renderAllSignals() {
    const fragments = { live: '', new: '', history: '' };
    
    // Sort history to show newest first
    allSignals.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    allSignals.forEach(s => {
        if (s.status === 'live') fragments.live += createLiveSignalCard(s);
        else if (s.status === 'new') fragments.new += createNewSignalCard(s);
        else if (s.status === 'closed' || s.status === 'error') fragments.history += createHistorySignalCard(s);
    });

    liveSignalsBox.innerHTML = fragments.live || '<p style="text-align:center; color: var(--text-muted)">No live signals.</p>';
    newSignalsBox.innerHTML = fragments.new || '<p style="text-align:center; color: var(--text-muted)">AI is scanning... No new signals approved yet.</p>';
    historyBox.innerHTML = fragments.history || '<p style="text-align:center; color: var(--text-muted)">No trade history.</p>';
    
    // Add click listeners to all cards for position sizing
    document.querySelectorAll('.signal-card').forEach(card => {
        card.addEventListener('click', (e) => {
            const signalId = parseInt(e.currentTarget.dataset.id);
            const signal = allSignals.find(s => s.id === signalId);
            if(signal) updatePositionAdvice(signal);
        });
    });
}

function createLiveSignalCard(s) {
    const pnl = s.pnl_usd || 0;
    const pnlClass = pnl >= 0 ? 'price-up' : 'price-down';
    const pnlSign = pnl >= 0 ? '+' : '';
    return `
      <div class="signal-card status-live" data-id="${s.id}">
        <div class="signal-header">
          <strong>${s.pair}</strong>
          <span class="signal-pnl ${pnlClass}">${pnlSign}$${pnl.toFixed(2)}</span>
        </div>
        <p><b>${s.type}</b> | Entry: ${s.entry.toFixed(4)}</p>
        <p>Current Price: <b class="${pnlClass}">${(lastPrices[s.symbolCode]?.price || 0).toFixed(4)}</b></p>
        <p>SL: ${s.sl.toFixed(4)} | TP: ${s.tp.join(' / ')}</p>
        <div class="signal-footer">Live Since: ${new Date(s.entryTime).toLocaleTimeString()}</div>
      </div>
    `;
}

function createNewSignalCard(s) {
    return `
      <div class="signal-card" data-id="${s.id}">
        <div class="signal-header">
          <strong>${s.pair}</strong>
          <b class="type-${s.type.toLowerCase()}">${s.type}</b>
        </div>
        <p>Entry Price: ${s.entry.toFixed(4)}</p>
        <p>SL: ${s.sl.toFixed(4)} | TP: ${s.tp.join(' / ')}</p>
        <p>Win Chance: <b class="price-up">${s.winChance}%</b></p>
        <div class="signal-footer">Approved at: ${new Date(s.createdAt).toLocaleTimeString()}</div>
      </div>
    `;
}

function createHistorySignalCard(s) {
    const isWin = s.result && s.result.includes('Win');
    const isError = s.status === 'error';
    const cardClass = isError ? 'status-error' : (isWin ? 'status-win' : 'status-loss');
    const pnlClass = s.pnl_usd >= 0 ? 'price-up' : 'price-down';
    const pnlSign = s.pnl_usd >= 0 ? '+' : '';
    const pnlText = s.pnl_usd ? `${pnlSign}$${s.pnl_usd.toFixed(2)}` : 'N/A';
    
    return `
      <div class="signal-card ${cardClass}" data-id="${s.id}">
        <div class="signal-header">
          <strong>${s.pair} (${s.type})</strong>
          <b>${s.result}</b>
        </div>
        <p>Entry: ${s.entry.toFixed(4)} | Closed: ${(s.closePrice || 0).toFixed(4)}</p>
        <p><strong>Final P/L: <span class="${pnlClass}">${pnlText}</span></strong></p>
        <div class="signal-footer">Created: ${new Date(s.createdAt).toLocaleTimeString()}</div>
      </div>
    `;
}


// =================================================================
// 5. UTILITIES
// =================================================================

function populateSymbolDropdown() {
    symbols.forEach((s) => {
        const opt = document.createElement("option");
        opt.value = s.code;
        opt.textContent = s.label;
        symbolSelect.appendChild(opt);
    });
    symbolSelect.addEventListener("change", (e) => loadChart(e.target.value));
}

function loadChart(sym) {
    if (tvWidget) {
      tvWidget.setSymbol(sym, "5", () => {});
    } else {
      tvWidget = new TradingView.widget({
        container_id: "tvChart", symbol: sym, interval: "5", timezone: "Asia/Dhaka", theme: "dark", style: "1",
        locale: "en", allow_symbol_change: false, width: "100%", height: 500,
      });
    }
}

async function refreshMarketData() {
    try {
        const binance = await axios.get("https://api.binance.com/api/v3/ticker/24hr");
        const cryptoData = binance.data;
        
        let tableHtml = "";
        symbols.forEach((sym) => {
            let price, chg;
            if (sym.code.startsWith("BINANCE:")) {
                const d = cryptoData.find((x) => x.symbol === sym.code.split(":")[1]);
                if (!d) return;
                price = parseFloat(d.lastPrice);
                chg = parseFloat(d.priceChangePercent);
            } else { // Mock price for non-crypto
                const lastPrice = lastPrices[sym.code]?.price ?? 100 + Math.random() * 500;
                price = lastPrice + (Math.random() - 0.5) * lastPrice * 0.003;
                chg = ((price - lastPrice) / lastPrice) * 1000;
            }
            lastPrices[sym.code] = { price, chg }; // Update master price list

            const cls = chg >= 0 ? 'price-up' : 'price-down';
            tableHtml += `<tr><td>${sym.label}</td><td class="${cls}">${price.toFixed(4)}</td><td class="${cls}">${chg >= 0 ? "+" : ""}${chg.toFixed(2)}%</td></tr>`;
        });
        tableBody.innerHTML = tableHtml;

        // After updating prices, re-process signals immediately for responsiveness
        processSignals();

    } catch (e) { console.error("Market refresh error:", e); }
}

function updatePositionAdvice(signal) {
    const balance = parseFloat(balanceInput.value) || 0;
    const riskUsd = (balance * TRADE_RISK_PERCENT) / 100;
    const diff = Math.abs(signal.entry - signal.sl);
    if (balance === 0 || diff === 0) {
        adviceBox.textContent = `Set balance to calculate size.`;
        return;
    }
    const qty = (riskUsd / diff);
    adviceBox.textContent = `For ${signal.pair} ${signal.type}: Risking $${riskUsd.toFixed(2)} ▶ Position Qty ≈ ${qty.toFixed(4)}`;
}


// =================================================================
// 6. START THE APP
// =================================================================
initializeApp();
</script>
</body>
</html>
