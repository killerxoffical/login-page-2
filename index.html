<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>kVT AI LIVE SIGNAL Dashboard (Visible Analysis)</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
  rel="stylesheet"
/>
<style>
  :root {
    --bg: #0f172a;
    --panel: #1e293b;
    --accent: #4ade80;
    --danger: #ef4444;
    --warn: #fbbf24;
    --text: #e2e8f0;
    --text-muted: #94a3b8;
    --blue: #60a5fa;
    --purple: #c084fc;
    --error: #737373;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: Poppins, Segoe UI, sans-serif;
    background: var(--bg);
    color: var(--text);
  }
  header {
    background: #020617;
    padding: 1rem 2rem;
    text-align: center;
    user-select: none;
  }
  header h1 {
    color: var(--accent);
    font-size: 1.8rem;
    letter-spacing: 1px;
    margin: 0;
  }
  main {
    padding: 1rem 2rem 2rem;
    max-width: 1600px; /* Increased max-width for 4 columns */
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
  #tvChart { width: 100%; height: 450px; border-radius: 12px; border: 1px solid #334155; }
  #controlsPanel {
    background: var(--panel);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    display: flex; flex-wrap: wrap; align-items: center; gap: 1.5rem;
  }
  #symbolSelect, #balanceInput {
    background: #334155; color: var(--text); border: none;
    border-radius: 6px; padding: 0.5rem 1rem; font-size: 1rem;
  }
  #balanceInput { width: 150px; }
  #positionAdvice { color: var(--accent); font-size: 0.9rem; font-weight: 600; user-select: none; flex-grow: 1; text-align: right; }
  
  /* --- 4-COLUMN SIGNAL LAYOUT --- */
  #signalsContainer {
    display: grid;
    /* 4 columns on large screens, 2 on medium, 1 on small */
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
  }

  .signals-section {
    background: var(--panel); border-radius: 12px; padding: 1rem;
    display: flex; flex-direction: column; gap: 1rem; min-height: 300px;
  }
  .signals-section h2 {
    margin: 0 0 0.5rem 0; font-size: 1.2rem; border-bottom: 1px solid #334155;
    padding-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center;
  }
  .signals-section h2.title-live { color: var(--warn); }
  .signals-section h2.title-potential { color: var(--purple); }
  .signals-section h2.title-new { color: var(--blue); }
  .signals-section h2.title-history { color: var(--text-muted); }

  #analysisStatus {
    font-size: 0.8rem; font-weight: 400; color: var(--warn);
    animation: blink 1.5s infinite;
  }
  @keyframes blink { 50% { opacity: 0.6; } }

  .signals-box { display: flex; flex-direction: column; gap: 1rem; overflow-y: auto; flex-grow: 1; }
  .signal-card {
    background: var(--bg); border: 1px solid #334155; border-radius: 8px;
    padding: 1rem; transition: 0.3s; user-select: none;
    font-size: 0.9rem; cursor: pointer;
  }
  .signal-card:hover { border-color: var(--blue); }
  
  /* --- BORDER COLORS FOR EACH STATUS --- */
  .signal-card.status-potential { border-left: 5px solid var(--purple); }
  .signal-card.status-new { border-left: 5px solid var(--blue); }
  .signal-card.status-live { border-left: 5px solid var(--warn); animation: pulse-border 2s infinite; }
  .signal-card.status-win { border-left: 5px solid var(--accent); }
  .signal-card.status-loss { border-left: 5px solid var(--danger); }
  .signal-card.status-error { border-left: 5px solid var(--error); }
  
  @keyframes pulse-border {
    0% { border-color: var(--warn); }
    50% { border-color: #fde047; } /* Brighter yellow */
    100% { border-color: var(--warn); }
  }
  
  .signal-card p { margin: 0.3rem 0; }
  .signal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
  .signal-header strong { font-size: 1.1rem; }
  .signal-header .type-buy { color: var(--accent); }
  .signal-header .type-sell { color: var(--danger); }
  .price-up { color: var(--accent); }
  .price-down { color: var(--danger); }
  .signal-pnl { font-weight: 600; font-size: 1.1rem; }
  .signal-footer { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.75rem; }

  #marketTableContainer { background: var(--panel); border-radius: 12px; padding: 1rem; }
  #marketTableContainer h2 { color: var(--blue); margin: 0 0 0.75rem 0; font-size: 1.1rem; }
  .live-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
  .live-table th, .live-table td { padding: 0.5rem 0.75rem; text-align: center; border-bottom: 1px solid #334155; }
</style>
</head>
<body>
<header><h1>kVT AI LIVE SIGNAL</h1></header>
<main>
  <div id="tvChart"></div>

  <div id="controlsPanel">
    <select id="symbolSelect"></select>
    <label for="balanceInput" style="color: var(--text); font-weight: 600;">Your Balance (USD):</label>
    <input type="number" id="balanceInput" value="1000" min="10" step="1" />
    <div id="positionAdvice">Click a signal for position size advice</div>
  </div>

  <div id="signalsContainer">
    <!-- NEW SECTION for visible analysis -->
    <section class="signals-section">
      <h2 class="title-potential">Analysis Pipeline <span id="analysisStatus" style="display:none;"></span></h2>
      <div id="potentialSignalsBox" class="signals-box"><p>AI is warming up...</p></div>
    </section>

    <section class="signals-section">
      <h2 class="title-new">New Signals</h2>
      <div id="newSignalsBox" class="signals-box"><p>No new signals approved.</p></div>
    </section>
    
    <section class="signals-section">
      <h2 class="title-live">Live Signals</h2>
      <div id="liveSignalsBox" class="signals-box"><p>No live signals.</p></div>
    </section>

    <section class="signals-section">
      <h2 class="title-history">Trade History</h2>
      <div id="historyBox" class="signals-box"><p>No trade history.</p></div>
    </section>
  </div>

  <div id="marketTableContainer">
    <h2>All Markets (2s Refresh)</h2>
    <table class="live-table" id="marketTable">
      <thead><tr><th>Pair</th><th>Price</th><th>24h %</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</main>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<script src="https://s3.tradingview.com/tv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios@1.6.8/dist/axios.min.js"></script>
<script>
// =================================================================
// 1. CONFIGURATION & INITIALIZATION
// =================================================================
const symbols = [
    { code: "BINANCE:BTCUSDT", label: "BTC/USDT" }, { code: "BINANCE:ETHUSDT", label: "ETH/USDT" },
    { code: "BINANCE:BNBUSDT", label: "BNB/USDT" }, { code: "BINANCE:SOLUSDT", label: "SOL/USDT" },
    { code: "BINANCE:XRPUSDT", label: "XRP/USDT" }, { code: "OANDA:XAUUSD", label: "GOLD" },
    { code: "TVC:USOIL", label: "US OIL" }, { code: "NASDAQ:TSLA", label: "TSLA" }
];
const TRADE_RISK_PERCENT = 2.0;
// --- FASTER TIMERS FOR DEMONSTRATION ---
const MARKET_REFRESH_INTERVAL = 2000; // 2 seconds
const SIGNAL_SCAN_INTERVAL = 10000; // Scan for trades every 10 seconds
const ANALYSIS_INTERVAL = 5000; // Analyze potential trades every 5 seconds
const APPROVAL_WIN_CHANCE = 65; // Approve signals with >65% win chance

// --- DOM Elements ---
const symbolSelect = document.getElementById("symbolSelect");
const balanceInput = document.getElementById("balanceInput");
const adviceBox = document.getElementById("positionAdvice");
const tableBody = document.querySelector("#marketTable tbody");
const potentialSignalsBox = document.getElementById("potentialSignalsBox"); // New box
const liveSignalsBox = document.getElementById("liveSignalsBox");
const newSignalsBox = document.getElementById("newSignalsBox");
const historyBox = document.getElementById("historyBox");
const analysisStatus = document.getElementById("analysisStatus");

// --- Firebase Config ---
const firebaseConfig = {
    apiKey: "AIzaSyBhATVeER6lVomkHqfvbtcM8j-xhLR8ZyY",
    databaseURL: "https://ff-cash-587aa-default-rtdb.firebaseio.com",
    projectId: "ff-cash-587aa",
};
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
const signalsRef = database.ref('signals_v2'); // Using a new path to not conflict with old data

// --- State Variables ---
let tvWidget, allSignals = [], lastPrices = {};

// =================================================================
// 2. CORE APPLICATION LOGIC
// =================================================================
function initializeApp() {
    populateSymbolDropdown();
    loadChart(symbolSelect.value);

    signalsRef.on('value', (snapshot) => {
        const data = snapshot.val();
        allSignals = data ? Object.values(data) : [];
        processSignals();
        renderAllSignals();
    });

    setInterval(refreshMarketData, MARKET_REFRESH_INTERVAL);
    setInterval(signalScanner, SIGNAL_SCAN_INTERVAL);
    setInterval(secondaryAnalyzer, ANALYSIS_INTERVAL);
}

// =================================================================
// 3. SIGNAL PROCESSING PIPELINE
// =================================================================
function signalScanner() {
    analysisStatus.textContent = 'Scanning...';
    analysisStatus.style.display = 'inline';

    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
    const priceData = lastPrices[randomSymbol.code];
    const hasExistingSignal = allSignals.some(s => s.symbolCode === randomSymbol.code && s.status !== 'closed' && s.status !== 'error');

    if (priceData && !hasExistingSignal) {
        const basePrice = priceData.price;
        const dir = Math.random() > 0.5 ? "BUY" : "SELL";
        const volatility = 0.02;
        
        const entry = basePrice * (dir === 'BUY' ? 0.998 : 1.002);
        const sl = entry * (dir === 'BUY' ? (1 - volatility) : (1 + volatility));
        const tp1 = entry * (dir === 'BUY' ? (1 + volatility * 0.7) : (1 - volatility * 0.7));
        const tp2 = entry * (dir === 'BUY' ? (1 + volatility * 1.5) : (1 - volatility * 1.5));
        
        const signalId = Date.now();
        const newSignal = {
            id: signalId, pair: randomSymbol.label, symbolCode: randomSymbol.code,
            status: 'potential', type: dir, entry, sl, tp: [tp1, tp2],
            winChance: Math.floor(50 + Math.random() * 48), // 50% to 98%
            createdAt: new Date().toISOString(),
        };
        database.ref('signals_v2/' + signalId).set(newSignal);
    }
    setTimeout(() => { analysisStatus.style.display = 'none'; }, 2000);
}

function secondaryAnalyzer() {
    const potentialSignals = allSignals.filter(s => s.status === 'potential');
    if (potentialSignals.length === 0) return;

    analysisStatus.textContent = 'Analyzing...';
    analysisStatus.style.display = 'inline';

    potentialSignals.forEach(signal => {
        if (signal.winChance > APPROVAL_WIN_CHANCE) {
            database.ref('signals_v2/' + signal.id).update({ status: 'new' });
        }
    });
    setTimeout(() => { analysisStatus.style.display = 'none'; }, 2000);
}

function processSignals() {
    const balance = parseFloat(balanceInput.value) || 0;
    allSignals.forEach(signal => {
        const currentPriceData = lastPrices[signal.symbolCode];
        if (!currentPriceData && ['live', 'new'].includes(signal.status)) {
             database.ref('signals_v2/' + signal.id).update({ status: 'error', result: 'Price data lost' });
             return;
        }
        if (!currentPriceData) return;
        const currentPrice = currentPriceData.price;
        const updates = {};
        if (signal.status === 'new') {
            const hasHitEntry = (signal.type === 'BUY' && currentPrice <= signal.entry) || (signal.type === 'SELL' && currentPrice >= signal.entry);
            if (hasHitEntry) {
                updates.status = 'live';
                updates.entryTime = new Date().toISOString();
                const riskUsd = (balance * TRADE_RISK_PERCENT) / 100;
                updates.quantity = (riskUsd / Math.abs(signal.entry - signal.sl));
            }
        }
        if (signal.status === 'live') {
            updates.pnl_usd = (currentPrice - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
            const hasHitSL = (signal.type === 'BUY' && currentPrice <= signal.sl) || (signal.type === 'SELL' && currentPrice >= signal.sl);
            if (hasHitSL) {
                updates.status = 'closed'; updates.result = 'Loss'; updates.closePrice = signal.sl;
                updates.pnl_usd = (signal.sl - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
            } else {
                for (let i = signal.tp.length - 1; i >= 0; i--) {
                    if ((signal.type === 'BUY' && currentPrice >= signal.tp[i]) || (signal.type === 'SELL' && currentPrice <= signal.tp[i])) {
                        updates.status = 'closed'; updates.result = `Win (TP${i+1})`; updates.closePrice = signal.tp[i];
                        updates.pnl_usd = (signal.tp[i] - signal.entry) * signal.quantity * (signal.type === 'BUY' ? 1 : -1);
                        break;
                    }
                }
            }
        }
        if (Object.keys(updates).length > 0) {
            database.ref('signals_v2/' + signal.id).update(updates);
        }
    });
}

// =================================================================
// 4. UI RENDERING
// =================================================================
function renderAllSignals() {
    const fragments = { potential: '', new: '', live: '', history: '' };
    allSignals.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    allSignals.forEach(s => {
        if (s.status === 'potential') fragments.potential += createCard(s);
        else if (s.status === 'new') fragments.new += createCard(s);
        else if (s.status === 'live') fragments.live += createCard(s);
        else if (s.status === 'closed' || s.status === 'error') fragments.history += createCard(s);
    });
    potentialSignalsBox.innerHTML = fragments.potential || '<p style="text-align:center; color: var(--text-muted)">No potential signals found yet.</p>';
    newSignalsBox.innerHTML = fragments.new || '<p style="text-align:center; color: var(--text-muted)">No new signals approved.</p>';
    liveSignalsBox.innerHTML = fragments.live || '<p style="text-align:center; color: var(--text-muted)">No live signals.</p>';
    historyBox.innerHTML = fragments.history || '<p style="text-align:center; color: var(--text-muted)">No trade history.</p>';
    
    document.querySelectorAll('.signal-card').forEach(card => card.addEventListener('click', (e) => {
        const signal = allSignals.find(s => s.id === parseInt(e.currentTarget.dataset.id));
        if(signal) updatePositionAdvice(signal);
    }));
}

function createCard(s) {
    let content = '';
    const header = `
      <div class="signal-header">
        <strong>${s.pair}</strong>
        <b class="type-${s.type.toLowerCase()}">${s.type}</b>
      </div>`;

    switch(s.status) {
        case 'potential':
            content = `
              ${header}
              <p>Entry: ${s.entry.toFixed(4)} | SL: ${s.sl.toFixed(4)}</p>
              <p>Win Chance: <b style="color: ${s.winChance > APPROVAL_WIN_CHANCE ? 'var(--accent)' : 'var(--warn)'}">${s.winChance}%</b></p>
              <div class="signal-footer">Awaiting analysis...</div>`;
            break;
        case 'new':
            content = `
              ${header}
              <p>Entry Price: ${s.entry.toFixed(4)}</p>
              <p>SL: ${s.sl.toFixed(4)} | TP: ${s.tp.join(' / ')}</p>
              <div class="signal-footer">Approved! Awaiting entry price.</div>`;
            break;
        case 'live':
            const pnl = s.pnl_usd || 0;
            const pnlClass = pnl >= 0 ? 'price-up' : 'price-down';
            content = `
              <div class="signal-header">
                <strong>${s.pair}</strong>
                <span class="signal-pnl ${pnlClass}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}</span>
              </div>
              <p><b>${s.type}</b> | Entry: ${s.entry.toFixed(4)}</p>
              <p>Current: <b class="${pnlClass}">${(lastPrices[s.symbolCode]?.price || 0).toFixed(4)}</b></p>
              <div class="signal-footer">Live Since: ${new Date(s.entryTime).toLocaleTimeString()}</div>`;
            break;
        case 'closed': case 'error':
            const isWin = s.result && s.result.includes('Win');
            const resultClass = s.status === 'error' ? 'status-error' : (isWin ? 'price-up' : 'price-down');
            const pnlFinal = s.pnl_usd || 0;
            content = `
              <div class="signal-header">
                <strong>${s.pair} (${s.type})</strong>
                <b class="${resultClass}">${s.result}</b>
              </div>
              <p>Entry: ${s.entry.toFixed(4)} | Closed: ${(s.closePrice || 0).toFixed(4)}</p>
              <p><strong>Final P/L: <span class="${resultClass}">${pnlFinal >= 0 ? '+' : ''}$${pnlFinal.toFixed(2)}</span></strong></p>
              <div class="signal-footer">Created: ${new Date(s.createdAt).toLocaleTimeString()}</div>`;
            break;
    }
    return `<div class="signal-card status-${s.status}" data-id="${s.id}">${content}</div>`;
}

// =================================================================
// 5. UTILITIES
// =================================================================
function populateSymbolDropdown() {
    symbols.forEach(s => symbolSelect.add(new Option(s.label, s.code)));
    symbolSelect.addEventListener("change", e => loadChart(e.target.value));
}
function loadChart(sym) {
    if (tvWidget) tvWidget.setSymbol(sym, "5", () => {});
    else tvWidget = new TradingView.widget({
        container_id: "tvChart", symbol: sym, interval: "5", timezone: "Asia/Dhaka", theme: "dark",
        style: "1", locale: "en", allow_symbol_change: false, autosize: true,
    });
}
async function refreshMarketData() {
    try {
        const binance = await axios.get("https://api.binance.com/api/v3/ticker/24hr");
        const cryptoData = binance.data;
        let tableHtml = "";
        symbols.forEach((sym) => {
            let price, chg;
            if (sym.code.startsWith("BINANCE:")) {
                const d = cryptoData.find((x) => x.symbol === sym.code.split(":")[1]);
                if (d) { price = parseFloat(d.lastPrice); chg = parseFloat(d.priceChangePercent); }
            } else {
                const last = lastPrices[sym.code]?.price ?? 100 + Math.random() * 500;
                price = last + (Math.random() - 0.5) * last * 0.003; chg = ((price - last) / last) * 1000;
            }
            if (price) {
                lastPrices[sym.code] = { price, chg };
                const cls = chg >= 0 ? 'price-up' : 'price-down';
                tableHtml += `<tr><td>${sym.label}</td><td class="${cls}">${price.toFixed(4)}</td><td class="${cls}">${chg >= 0 ? "+" : ""}${chg.toFixed(2)}%</td></tr>`;
            }
        });
        tableBody.innerHTML = tableHtml;
        processSignals();
    } catch (e) { console.error("Market refresh error:", e); }
}
function updatePositionAdvice(signal) {
    const balance = parseFloat(balanceInput.value) || 0;
    const riskUsd = (balance * TRADE_RISK_PERCENT) / 100;
    const diff = Math.abs(signal.entry - signal.sl);
    if (!balance || !diff) { adviceBox.textContent = `Set balance to calculate size.`; return; }
    const qty = (riskUsd / diff);
    adviceBox.textContent = `For ${signal.pair} ${signal.type}: Risking $${riskUsd.toFixed(2)} ▶ Qty ≈ ${qty.toFixed(4)}`;
}

initializeApp();
</script>
</body>
</html>
